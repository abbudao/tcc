\section{Motivação e Contextualização}
Nas últimas décadas, o interesse por programação cresceu de forma extraordinária 
e cursos introdutórios mostram-se cada vez mais populares. No entanto, 
cursos de programação ainda são considerados difíceis e, com frequência,
possuem taxas de desistência elevada. Iniciantes sofrem de uma 
vasta gama de déficits e dificuldades, desde a compreensão de constructos 
básicos de uma linguagem de programação à elaboração de planos
para resolver um dado problema \ \cite{robins2003learning}.

Um grande número de estudos concluem, de forma semelhante, que alunos, 
mesmo tendo aprendido a sintaxe e semântica de uma linguagem 
de progamação, tendem a falhar em compor os blocos fundamentais 
estudados em programas  válidos. Parte deste problema é abordado por 
\citeonline{davies1993models}, que faz uma distinção de duas partes 
essencias no aprendizado em programação: 
conhecimento e estratégia. Denota-se conhecimento em programação como a parte declarativa 
do conhecimento, \emph{e.g.\ } saber que existe um constructo chamado \emph{for} na linguagem 
e seu propósito. Já estratégia em programação seria empregar de forma adequada o conhecimento 
em face de um problema, como o uso pertinente de um \emph{for} em um programa.\\
\citeonline{davies1993models} defende que grande parte das abordagens em ensino 
tendem a investir excessivamente na parcela de conhecimento em programação, muitas 
vezes deixando de lado o aspecto de estratégia.

Além desta falta de enfâse no ensino de estratégia em programação,
\citeonline{winslow1996programming} afirma que, ainda que o aluno saiba resolver 
manualmente o problema,
existe uma grande dificuldade na adaptação 
desta solução para seu equivalente em um programa de computador. Este fato 
corrobora com a teoria de \citeonline{brooks1983towards} em que se afirma que programação 
é o processo de construir mapeamentos entre o domínio problema, possivelmente passando 
por muitos domínios intermediários, para chegar finalmente no domínio da programação. 
Por esta teoria, o entendimento de um programa nada mais é que a reconstrução de 
ao menos uma parte destas relações entre domínios e que este processo é orientado 
a criação, confirmação e refinamento de hipóteses.

A complexidade da tarefa não só se concentra no ensino de conhecimento e 
estratégia em programação nem na elaboração de habilidades que relacionem o domínio 
do problema ao domínio da programação, mas na flexibilidade que o iniciante deve 
alcançar na resolução de problemas. Desta forma, o processo de escrita 
de um programa deve  ser oportunística e incremental, em que o plano adotado 
e problema sempre estão em 
constante reavaliação, e que isto pode resultar em desvios e reformulações do plano
original \ \cite{visser1990more}. \\
Para que seja possível instrumentalizar esta escrita oportunística e incremental, 
o aluno deve adquirir outras habilidades como \emph{debugging} de programas e 
familiaridade com um ambiente de programação.

Em vista ao imenso desafio que é o ensino de programação a iniciantes, diversas ferramentas 
foram desenvolvidas para dar apoio pedagócio ao professor nesta tarefa. Uma razoável parcela 
destas ferramentas são sistemas de juízes \emph{online}, que consistem em sistemas capazes 
de receber códigos desenvolvidos pelos usuários como resposta a um determinado problema, mas 
com a capacidade de dar um \emph{feedback} imediato ao usuário, informando 
se o código está correto ou não, através de análise sintática e testes automatizados.

Já existe uma grande variedade em juízes \emph{online} disponíveis na literatura científica,
tais como: 
\hyperref[link:the_huxley]{\emph{The Huxley}} [\citeonline{de2013ferramenta}], 
	\hyperref[link:code_bench]{\emph{CodeBench}} [\citeonline{galvao2016juiz}],  
	\hyperref[link:uva_judge]{\emph{UVa Online Judge}} [\citeonline{revilla2008competitive}], 
	\hyperref[link:feeper]{\emph{feeper}} [\citeonline{alves2014ambiente}], 
	\hyperref[link:uri_judge]{\emph{URI Online Judge}} [\citeonline{bez2014uri}], 
	\hyperref[link:boca]{\emph{BOCA}} [\citeonline{de2004boca}],
	\hyperref[link:we_run_codes]{\emph{RunCodes}},
	\hyperref[link:sphere_judge]{\emph{Sphere Online Judge}},
	\hyperref[link:hacker_rank]{\emph{HackerRank}}, 
	\hyperref[link:code_chef]{\emph{CodeChef}}, 
	\hyperref[link:interview_bit]{\emph{InterviewBit}}, 
	\hyperref[link:kattis]{\emph{Kattis}}, 
	\hyperref[link:leet_code]{\emph{LeetCode}}, 
	\hyperref[link:codin_game]{\emph{CodinGame}}, 
	\hyperref[link:code_signal]{\emph{CodeSignal}}, 
	\hyperref[link:code_wars]{\emph{CodeWars}}, 
	\hyperref[link:exercism]{\emph{Exercism}}, 
	entre tantos outros.

Apesar da grande variedade e maturidade destas plataformas existentes, poucas 
têm como foco ser uma ferramenta de auxílio didático ao professor em sala de aula e 
praticamente nenhuma é de código aberto. Assim sendo, existe uma lacuna que pode
ser preenchida por um sistema que tenha estes dois focos e dê liberdade ao professor 
a implementar técnicas de ensino que o convenha.


\section{Objetivos}
Pretende-se neste trabalho desenvolver uma prova de conceito de um sistema para apoio 
ao ensino de programação em salas de aula, que seja de código aberto e que forneça 
ferramentas necessárias para o professor conduzir e monitorar exercícios práticos dados 
em sala de aula.

\section{Organização}
No Capítulo 2 pretende-se fazer uma revisão bibliográfica das técnicas empregadas na implementação 
da prova de conceito do sistema \emph{Sharpener}. A seguir no Capítulo 3 descreve-se a especificação 
funcional do sistema tais como seus detalhes de implementação. Finalmente no Capítulo 4 apresentam-se 
os resultados e possíveis trabalhos futuros.
%\aspas
%\sigla
% Comando simples para exibir comandos Latex no texto
% \cite{frasson:2005:classe_abnt}.

